// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'staking_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StakingBlocEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StakingBlocEventCopyWith<$Res> {
  factory $StakingBlocEventCopyWith(
          StakingBlocEvent value, $Res Function(StakingBlocEvent) then) =
      _$StakingBlocEventCopyWithImpl<$Res, StakingBlocEvent>;
}

/// @nodoc
class _$StakingBlocEventCopyWithImpl<$Res, $Val extends StakingBlocEvent>
    implements $StakingBlocEventCopyWith<$Res> {
  _$StakingBlocEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitImplCopyWith<$Res> {
  factory _$$InitImplCopyWith(
          _$InitImpl value, $Res Function(_$InitImpl) then) =
      __$$InitImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$InitImpl>
    implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitImpl implements _Init {
  const _$InitImpl();

  @override
  String toString() {
    return 'StakingBlocEvent.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _Init implements StakingBlocEvent {
  const factory _Init() = _$InitImpl;
}

/// @nodoc
abstract class _$$SelectMaxImplCopyWith<$Res> {
  factory _$$SelectMaxImplCopyWith(
          _$SelectMaxImpl value, $Res Function(_$SelectMaxImpl) then) =
      __$$SelectMaxImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SelectMaxImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$SelectMaxImpl>
    implements _$$SelectMaxImplCopyWith<$Res> {
  __$$SelectMaxImplCopyWithImpl(
      _$SelectMaxImpl _value, $Res Function(_$SelectMaxImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SelectMaxImpl implements _SelectMax {
  const _$SelectMaxImpl();

  @override
  String toString() {
    return 'StakingBlocEvent.selectMax()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SelectMaxImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return selectMax();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return selectMax?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (selectMax != null) {
      return selectMax();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return selectMax(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return selectMax?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (selectMax != null) {
      return selectMax(this);
    }
    return orElse();
  }
}

abstract class _SelectMax implements StakingBlocEvent {
  const factory _SelectMax() = _$SelectMaxImpl;
}

/// @nodoc
abstract class _$$DoActionImplCopyWith<$Res> {
  factory _$$DoActionImplCopyWith(
          _$DoActionImpl value, $Res Function(_$DoActionImpl) then) =
      __$$DoActionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DoActionImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$DoActionImpl>
    implements _$$DoActionImplCopyWith<$Res> {
  __$$DoActionImplCopyWithImpl(
      _$DoActionImpl _value, $Res Function(_$DoActionImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$DoActionImpl implements _DoAction {
  const _$DoActionImpl();

  @override
  String toString() {
    return 'StakingBlocEvent.doAction()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DoActionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return doAction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return doAction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (doAction != null) {
      return doAction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return doAction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return doAction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (doAction != null) {
      return doAction(this);
    }
    return orElse();
  }
}

abstract class _DoAction implements StakingBlocEvent {
  const factory _DoAction() = _$DoActionImpl;
}

/// @nodoc
abstract class _$$UpdateRequestsImplCopyWith<$Res> {
  factory _$$UpdateRequestsImplCopyWith(_$UpdateRequestsImpl value,
          $Res Function(_$UpdateRequestsImpl) then) =
      __$$UpdateRequestsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<StEverWithdrawRequest> requests});
}

/// @nodoc
class __$$UpdateRequestsImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$UpdateRequestsImpl>
    implements _$$UpdateRequestsImplCopyWith<$Res> {
  __$$UpdateRequestsImplCopyWithImpl(
      _$UpdateRequestsImpl _value, $Res Function(_$UpdateRequestsImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requests = null,
  }) {
    return _then(_$UpdateRequestsImpl(
      null == requests
          ? _value._requests
          : requests // ignore: cast_nullable_to_non_nullable
              as List<StEverWithdrawRequest>,
    ));
  }
}

/// @nodoc

class _$UpdateRequestsImpl implements _UpdateRequests {
  const _$UpdateRequestsImpl(final List<StEverWithdrawRequest> requests)
      : _requests = requests;

  final List<StEverWithdrawRequest> _requests;
  @override
  List<StEverWithdrawRequest> get requests {
    if (_requests is EqualUnmodifiableListView) return _requests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requests);
  }

  @override
  String toString() {
    return 'StakingBlocEvent.updateResuests(requests: $requests)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateRequestsImpl &&
            const DeepCollectionEquality().equals(other._requests, _requests));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_requests));

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateRequestsImplCopyWith<_$UpdateRequestsImpl> get copyWith =>
      __$$UpdateRequestsImplCopyWithImpl<_$UpdateRequestsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return updateResuests(requests);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return updateResuests?.call(requests);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (updateResuests != null) {
      return updateResuests(requests);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return updateResuests(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return updateResuests?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (updateResuests != null) {
      return updateResuests(this);
    }
    return orElse();
  }
}

abstract class _UpdateRequests implements StakingBlocEvent {
  const factory _UpdateRequests(final List<StEverWithdrawRequest> requests) =
      _$UpdateRequestsImpl;

  List<StEverWithdrawRequest> get requests;

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateRequestsImplCopyWith<_$UpdateRequestsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeTabImplCopyWith<$Res> {
  factory _$$ChangeTabImplCopyWith(
          _$ChangeTabImpl value, $Res Function(_$ChangeTabImpl) then) =
      __$$ChangeTabImplCopyWithImpl<$Res>;
  @useResult
  $Res call({StakingPageType type});
}

/// @nodoc
class __$$ChangeTabImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$ChangeTabImpl>
    implements _$$ChangeTabImplCopyWith<$Res> {
  __$$ChangeTabImplCopyWithImpl(
      _$ChangeTabImpl _value, $Res Function(_$ChangeTabImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$ChangeTabImpl(
      null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StakingPageType,
    ));
  }
}

/// @nodoc

class _$ChangeTabImpl implements _ChangeTab {
  const _$ChangeTabImpl(this.type);

  @override
  final StakingPageType type;

  @override
  String toString() {
    return 'StakingBlocEvent.changeTab(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeTabImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, type);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeTabImplCopyWith<_$ChangeTabImpl> get copyWith =>
      __$$ChangeTabImplCopyWithImpl<_$ChangeTabImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return changeTab(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return changeTab?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (changeTab != null) {
      return changeTab(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return changeTab(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return changeTab?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (changeTab != null) {
      return changeTab(this);
    }
    return orElse();
  }
}

abstract class _ChangeTab implements StakingBlocEvent {
  const factory _ChangeTab(final StakingPageType type) = _$ChangeTabImpl;

  StakingPageType get type;

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeTabImplCopyWith<_$ChangeTabImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateReceiveImplCopyWith<$Res> {
  factory _$$UpdateReceiveImplCopyWith(
          _$UpdateReceiveImpl value, $Res Function(_$UpdateReceiveImpl) then) =
      __$$UpdateReceiveImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Fixed value});
}

/// @nodoc
class __$$UpdateReceiveImplCopyWithImpl<$Res>
    extends _$StakingBlocEventCopyWithImpl<$Res, _$UpdateReceiveImpl>
    implements _$$UpdateReceiveImplCopyWith<$Res> {
  __$$UpdateReceiveImplCopyWithImpl(
      _$UpdateReceiveImpl _value, $Res Function(_$UpdateReceiveImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$UpdateReceiveImpl(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Fixed,
    ));
  }
}

/// @nodoc

class _$UpdateReceiveImpl implements _UpdateReceive {
  const _$UpdateReceiveImpl(this.value);

  @override
  final Fixed value;

  @override
  String toString() {
    return 'StakingBlocEvent.updateReceive(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateReceiveImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateReceiveImplCopyWith<_$UpdateReceiveImpl> get copyWith =>
      __$$UpdateReceiveImplCopyWithImpl<_$UpdateReceiveImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() selectMax,
    required TResult Function() doAction,
    required TResult Function(List<StEverWithdrawRequest> requests)
        updateResuests,
    required TResult Function(StakingPageType type) changeTab,
    required TResult Function(Fixed value) updateReceive,
  }) {
    return updateReceive(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function()? selectMax,
    TResult? Function()? doAction,
    TResult? Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult? Function(StakingPageType type)? changeTab,
    TResult? Function(Fixed value)? updateReceive,
  }) {
    return updateReceive?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? selectMax,
    TResult Function()? doAction,
    TResult Function(List<StEverWithdrawRequest> requests)? updateResuests,
    TResult Function(StakingPageType type)? changeTab,
    TResult Function(Fixed value)? updateReceive,
    required TResult orElse(),
  }) {
    if (updateReceive != null) {
      return updateReceive(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Init value) init,
    required TResult Function(_SelectMax value) selectMax,
    required TResult Function(_DoAction value) doAction,
    required TResult Function(_UpdateRequests value) updateResuests,
    required TResult Function(_ChangeTab value) changeTab,
    required TResult Function(_UpdateReceive value) updateReceive,
  }) {
    return updateReceive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Init value)? init,
    TResult? Function(_SelectMax value)? selectMax,
    TResult? Function(_DoAction value)? doAction,
    TResult? Function(_UpdateRequests value)? updateResuests,
    TResult? Function(_ChangeTab value)? changeTab,
    TResult? Function(_UpdateReceive value)? updateReceive,
  }) {
    return updateReceive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Init value)? init,
    TResult Function(_SelectMax value)? selectMax,
    TResult Function(_DoAction value)? doAction,
    TResult Function(_UpdateRequests value)? updateResuests,
    TResult Function(_ChangeTab value)? changeTab,
    TResult Function(_UpdateReceive value)? updateReceive,
    required TResult orElse(),
  }) {
    if (updateReceive != null) {
      return updateReceive(this);
    }
    return orElse();
  }
}

abstract class _UpdateReceive implements StakingBlocEvent {
  const factory _UpdateReceive(final Fixed value) = _$UpdateReceiveImpl;

  Fixed get value;

  /// Create a copy of StakingBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateReceiveImplCopyWith<_$UpdateReceiveImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StakingBlocState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preparing,
    required TResult Function() initError,
    required TResult Function(Object error) subscribeError,
    required TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preparing,
    TResult? Function()? initError,
    TResult? Function(Object error)? subscribeError,
    TResult? Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preparing,
    TResult Function()? initError,
    TResult Function(Object error)? subscribeError,
    TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Preparing value) preparing,
    required TResult Function(_InitError value) initError,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_StakingState value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Preparing value)? preparing,
    TResult? Function(_InitError value)? initError,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_StakingState value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Preparing value)? preparing,
    TResult Function(_InitError value)? initError,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_StakingState value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StakingBlocStateCopyWith<$Res> {
  factory $StakingBlocStateCopyWith(
          StakingBlocState value, $Res Function(StakingBlocState) then) =
      _$StakingBlocStateCopyWithImpl<$Res, StakingBlocState>;
}

/// @nodoc
class _$StakingBlocStateCopyWithImpl<$Res, $Val extends StakingBlocState>
    implements $StakingBlocStateCopyWith<$Res> {
  _$StakingBlocStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$PreparingImplCopyWith<$Res> {
  factory _$$PreparingImplCopyWith(
          _$PreparingImpl value, $Res Function(_$PreparingImpl) then) =
      __$$PreparingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PreparingImplCopyWithImpl<$Res>
    extends _$StakingBlocStateCopyWithImpl<$Res, _$PreparingImpl>
    implements _$$PreparingImplCopyWith<$Res> {
  __$$PreparingImplCopyWithImpl(
      _$PreparingImpl _value, $Res Function(_$PreparingImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PreparingImpl implements _Preparing {
  const _$PreparingImpl();

  @override
  String toString() {
    return 'StakingBlocState.preparing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PreparingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preparing,
    required TResult Function() initError,
    required TResult Function(Object error) subscribeError,
    required TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)
        data,
  }) {
    return preparing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preparing,
    TResult? Function()? initError,
    TResult? Function(Object error)? subscribeError,
    TResult? Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
  }) {
    return preparing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preparing,
    TResult Function()? initError,
    TResult Function(Object error)? subscribeError,
    TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
    required TResult orElse(),
  }) {
    if (preparing != null) {
      return preparing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Preparing value) preparing,
    required TResult Function(_InitError value) initError,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_StakingState value) data,
  }) {
    return preparing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Preparing value)? preparing,
    TResult? Function(_InitError value)? initError,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_StakingState value)? data,
  }) {
    return preparing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Preparing value)? preparing,
    TResult Function(_InitError value)? initError,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_StakingState value)? data,
    required TResult orElse(),
  }) {
    if (preparing != null) {
      return preparing(this);
    }
    return orElse();
  }
}

abstract class _Preparing implements StakingBlocState {
  const factory _Preparing() = _$PreparingImpl;
}

/// @nodoc
abstract class _$$InitErrorImplCopyWith<$Res> {
  factory _$$InitErrorImplCopyWith(
          _$InitErrorImpl value, $Res Function(_$InitErrorImpl) then) =
      __$$InitErrorImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitErrorImplCopyWithImpl<$Res>
    extends _$StakingBlocStateCopyWithImpl<$Res, _$InitErrorImpl>
    implements _$$InitErrorImplCopyWith<$Res> {
  __$$InitErrorImplCopyWithImpl(
      _$InitErrorImpl _value, $Res Function(_$InitErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitErrorImpl implements _InitError {
  const _$InitErrorImpl();

  @override
  String toString() {
    return 'StakingBlocState.initError()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitErrorImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preparing,
    required TResult Function() initError,
    required TResult Function(Object error) subscribeError,
    required TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)
        data,
  }) {
    return initError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preparing,
    TResult? Function()? initError,
    TResult? Function(Object error)? subscribeError,
    TResult? Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
  }) {
    return initError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preparing,
    TResult Function()? initError,
    TResult Function(Object error)? subscribeError,
    TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
    required TResult orElse(),
  }) {
    if (initError != null) {
      return initError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Preparing value) preparing,
    required TResult Function(_InitError value) initError,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_StakingState value) data,
  }) {
    return initError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Preparing value)? preparing,
    TResult? Function(_InitError value)? initError,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_StakingState value)? data,
  }) {
    return initError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Preparing value)? preparing,
    TResult Function(_InitError value)? initError,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_StakingState value)? data,
    required TResult orElse(),
  }) {
    if (initError != null) {
      return initError(this);
    }
    return orElse();
  }
}

abstract class _InitError implements StakingBlocState {
  const factory _InitError() = _$InitErrorImpl;
}

/// @nodoc
abstract class _$$SubscribeErrorImplCopyWith<$Res> {
  factory _$$SubscribeErrorImplCopyWith(_$SubscribeErrorImpl value,
          $Res Function(_$SubscribeErrorImpl) then) =
      __$$SubscribeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object error});
}

/// @nodoc
class __$$SubscribeErrorImplCopyWithImpl<$Res>
    extends _$StakingBlocStateCopyWithImpl<$Res, _$SubscribeErrorImpl>
    implements _$$SubscribeErrorImplCopyWith<$Res> {
  __$$SubscribeErrorImplCopyWithImpl(
      _$SubscribeErrorImpl _value, $Res Function(_$SubscribeErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$SubscribeErrorImpl(
      null == error ? _value.error : error,
    ));
  }
}

/// @nodoc

class _$SubscribeErrorImpl implements _SubscribeError {
  const _$SubscribeErrorImpl(this.error);

  @override
  final Object error;

  @override
  String toString() {
    return 'StakingBlocState.subscribeError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscribeErrorImpl &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscribeErrorImplCopyWith<_$SubscribeErrorImpl> get copyWith =>
      __$$SubscribeErrorImplCopyWithImpl<_$SubscribeErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preparing,
    required TResult Function() initError,
    required TResult Function(Object error) subscribeError,
    required TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)
        data,
  }) {
    return subscribeError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preparing,
    TResult? Function()? initError,
    TResult? Function(Object error)? subscribeError,
    TResult? Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
  }) {
    return subscribeError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preparing,
    TResult Function()? initError,
    TResult Function(Object error)? subscribeError,
    TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
    required TResult orElse(),
  }) {
    if (subscribeError != null) {
      return subscribeError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Preparing value) preparing,
    required TResult Function(_InitError value) initError,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_StakingState value) data,
  }) {
    return subscribeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Preparing value)? preparing,
    TResult? Function(_InitError value)? initError,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_StakingState value)? data,
  }) {
    return subscribeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Preparing value)? preparing,
    TResult Function(_InitError value)? initError,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_StakingState value)? data,
    required TResult orElse(),
  }) {
    if (subscribeError != null) {
      return subscribeError(this);
    }
    return orElse();
  }
}

abstract class _SubscribeError implements StakingBlocState {
  const factory _SubscribeError(final Object error) = _$SubscribeErrorImpl;

  Object get error;

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscribeErrorImplCopyWith<_$SubscribeErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StakingStateImplCopyWith<$Res> {
  factory _$$StakingStateImplCopyWith(
          _$StakingStateImpl value, $Res Function(_$StakingStateImpl) then) =
      __$$StakingStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {StakingPageType type,
      int withdrawTime,
      BigInt attachedAmount,
      bool canSubmitAction,
      TextEditingController inputController,
      double exchangeRate,
      Currency receiveCurrency,
      PublicKey accountKey,
      Money enteredPrice,
      AmountInputAsset asset,
      Money? receiveBalance,
      List<StEverWithdrawRequest>? requests,
      double? apy});
}

/// @nodoc
class __$$StakingStateImplCopyWithImpl<$Res>
    extends _$StakingBlocStateCopyWithImpl<$Res, _$StakingStateImpl>
    implements _$$StakingStateImplCopyWith<$Res> {
  __$$StakingStateImplCopyWithImpl(
      _$StakingStateImpl _value, $Res Function(_$StakingStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? withdrawTime = null,
    Object? attachedAmount = null,
    Object? canSubmitAction = null,
    Object? inputController = null,
    Object? exchangeRate = null,
    Object? receiveCurrency = null,
    Object? accountKey = freezed,
    Object? enteredPrice = null,
    Object? asset = null,
    Object? receiveBalance = freezed,
    Object? requests = freezed,
    Object? apy = freezed,
  }) {
    return _then(_$StakingStateImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as StakingPageType,
      withdrawTime: null == withdrawTime
          ? _value.withdrawTime
          : withdrawTime // ignore: cast_nullable_to_non_nullable
              as int,
      attachedAmount: null == attachedAmount
          ? _value.attachedAmount
          : attachedAmount // ignore: cast_nullable_to_non_nullable
              as BigInt,
      canSubmitAction: null == canSubmitAction
          ? _value.canSubmitAction
          : canSubmitAction // ignore: cast_nullable_to_non_nullable
              as bool,
      inputController: null == inputController
          ? _value.inputController
          : inputController // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      exchangeRate: null == exchangeRate
          ? _value.exchangeRate
          : exchangeRate // ignore: cast_nullable_to_non_nullable
              as double,
      receiveCurrency: null == receiveCurrency
          ? _value.receiveCurrency
          : receiveCurrency // ignore: cast_nullable_to_non_nullable
              as Currency,
      accountKey: freezed == accountKey
          ? _value.accountKey
          : accountKey // ignore: cast_nullable_to_non_nullable
              as PublicKey,
      enteredPrice: null == enteredPrice
          ? _value.enteredPrice
          : enteredPrice // ignore: cast_nullable_to_non_nullable
              as Money,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as AmountInputAsset,
      receiveBalance: freezed == receiveBalance
          ? _value.receiveBalance
          : receiveBalance // ignore: cast_nullable_to_non_nullable
              as Money?,
      requests: freezed == requests
          ? _value._requests
          : requests // ignore: cast_nullable_to_non_nullable
              as List<StEverWithdrawRequest>?,
      apy: freezed == apy
          ? _value.apy
          : apy // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc

class _$StakingStateImpl implements _StakingState {
  const _$StakingStateImpl(
      {required this.type,
      required this.withdrawTime,
      required this.attachedAmount,
      required this.canSubmitAction,
      required this.inputController,
      required this.exchangeRate,
      required this.receiveCurrency,
      required this.accountKey,
      required this.enteredPrice,
      required this.asset,
      this.receiveBalance,
      final List<StEverWithdrawRequest>? requests,
      this.apy})
      : _requests = requests;

// Type of current selected action
  @override
  final StakingPageType type;
  @override
  final int withdrawTime;
// Amount in EVER that will be attached to action
  @override
  final BigInt attachedAmount;
  @override
  final bool canSubmitAction;
  @override
  final TextEditingController inputController;
// How many [receiveBalance] could be received for [currentBalance].
// if we receive stever, then it should be displayed on right side, on left
// otherwise
  @override
  final double exchangeRate;
  @override
  final Currency receiveCurrency;
  @override
  final PublicKey accountKey;
// Price in real curreny of entered tokens
  @override
  final Money enteredPrice;
  @override
  final AmountInputAsset asset;
// Balance of token user select after action (stake-stever, unstake-ever)
  @override
  final Money? receiveBalance;
// Pending withdraw requests
  final List<StEverWithdrawRequest>? _requests;
// Pending withdraw requests
  @override
  List<StEverWithdrawRequest>? get requests {
    final value = _requests;
    if (value == null) return null;
    if (_requests is EqualUnmodifiableListView) return _requests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

// Average profit
  @override
  final double? apy;

  @override
  String toString() {
    return 'StakingBlocState.data(type: $type, withdrawTime: $withdrawTime, attachedAmount: $attachedAmount, canSubmitAction: $canSubmitAction, inputController: $inputController, exchangeRate: $exchangeRate, receiveCurrency: $receiveCurrency, accountKey: $accountKey, enteredPrice: $enteredPrice, asset: $asset, receiveBalance: $receiveBalance, requests: $requests, apy: $apy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StakingStateImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.withdrawTime, withdrawTime) ||
                other.withdrawTime == withdrawTime) &&
            (identical(other.attachedAmount, attachedAmount) ||
                other.attachedAmount == attachedAmount) &&
            (identical(other.canSubmitAction, canSubmitAction) ||
                other.canSubmitAction == canSubmitAction) &&
            (identical(other.inputController, inputController) ||
                other.inputController == inputController) &&
            (identical(other.exchangeRate, exchangeRate) ||
                other.exchangeRate == exchangeRate) &&
            (identical(other.receiveCurrency, receiveCurrency) ||
                other.receiveCurrency == receiveCurrency) &&
            const DeepCollectionEquality()
                .equals(other.accountKey, accountKey) &&
            (identical(other.enteredPrice, enteredPrice) ||
                other.enteredPrice == enteredPrice) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.receiveBalance, receiveBalance) ||
                other.receiveBalance == receiveBalance) &&
            const DeepCollectionEquality().equals(other._requests, _requests) &&
            (identical(other.apy, apy) || other.apy == apy));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      type,
      withdrawTime,
      attachedAmount,
      canSubmitAction,
      inputController,
      exchangeRate,
      receiveCurrency,
      const DeepCollectionEquality().hash(accountKey),
      enteredPrice,
      asset,
      receiveBalance,
      const DeepCollectionEquality().hash(_requests),
      apy);

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StakingStateImplCopyWith<_$StakingStateImpl> get copyWith =>
      __$$StakingStateImplCopyWithImpl<_$StakingStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() preparing,
    required TResult Function() initError,
    required TResult Function(Object error) subscribeError,
    required TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)
        data,
  }) {
    return data(
        type,
        withdrawTime,
        attachedAmount,
        canSubmitAction,
        inputController,
        exchangeRate,
        receiveCurrency,
        accountKey,
        enteredPrice,
        asset,
        receiveBalance,
        requests,
        apy);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? preparing,
    TResult? Function()? initError,
    TResult? Function(Object error)? subscribeError,
    TResult? Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
  }) {
    return data?.call(
        type,
        withdrawTime,
        attachedAmount,
        canSubmitAction,
        inputController,
        exchangeRate,
        receiveCurrency,
        accountKey,
        enteredPrice,
        asset,
        receiveBalance,
        requests,
        apy);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? preparing,
    TResult Function()? initError,
    TResult Function(Object error)? subscribeError,
    TResult Function(
            StakingPageType type,
            int withdrawTime,
            BigInt attachedAmount,
            bool canSubmitAction,
            TextEditingController inputController,
            double exchangeRate,
            Currency receiveCurrency,
            PublicKey accountKey,
            Money enteredPrice,
            AmountInputAsset asset,
            Money? receiveBalance,
            List<StEverWithdrawRequest>? requests,
            double? apy)?
        data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(
          type,
          withdrawTime,
          attachedAmount,
          canSubmitAction,
          inputController,
          exchangeRate,
          receiveCurrency,
          accountKey,
          enteredPrice,
          asset,
          receiveBalance,
          requests,
          apy);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Preparing value) preparing,
    required TResult Function(_InitError value) initError,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_StakingState value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Preparing value)? preparing,
    TResult? Function(_InitError value)? initError,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_StakingState value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Preparing value)? preparing,
    TResult Function(_InitError value)? initError,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_StakingState value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class _StakingState implements StakingBlocState {
  const factory _StakingState(
      {required final StakingPageType type,
      required final int withdrawTime,
      required final BigInt attachedAmount,
      required final bool canSubmitAction,
      required final TextEditingController inputController,
      required final double exchangeRate,
      required final Currency receiveCurrency,
      required final PublicKey accountKey,
      required final Money enteredPrice,
      required final AmountInputAsset asset,
      final Money? receiveBalance,
      final List<StEverWithdrawRequest>? requests,
      final double? apy}) = _$StakingStateImpl;

// Type of current selected action
  StakingPageType get type;
  int get withdrawTime; // Amount in EVER that will be attached to action
  BigInt get attachedAmount;
  bool get canSubmitAction;
  TextEditingController
      get inputController; // How many [receiveBalance] could be received for [currentBalance].
// if we receive stever, then it should be displayed on right side, on left
// otherwise
  double get exchangeRate;
  Currency get receiveCurrency;
  PublicKey get accountKey; // Price in real curreny of entered tokens
  Money get enteredPrice;
  AmountInputAsset
      get asset; // Balance of token user select after action (stake-stever, unstake-ever)
  Money? get receiveBalance; // Pending withdraw requests
  List<StEverWithdrawRequest>? get requests; // Average profit
  double? get apy;

  /// Create a copy of StakingBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StakingStateImplCopyWith<_$StakingStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
