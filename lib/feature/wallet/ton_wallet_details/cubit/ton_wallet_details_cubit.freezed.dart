// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ton_wallet_details_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TonWalletDetailsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() empty,
    required TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)
        subscribeError,
    required TResult Function(String symbol, KeyAccount account,
            Money tokenBalance, Money fiatBalance)
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? empty,
    TResult? Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult? Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? empty,
    TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Empty value) empty,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_Data value) data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Empty value)? empty,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_Data value)? data,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Empty value)? empty,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_Data value)? data,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TonWalletDetailsStateCopyWith<$Res> {
  factory $TonWalletDetailsStateCopyWith(TonWalletDetailsState value,
          $Res Function(TonWalletDetailsState) then) =
      _$TonWalletDetailsStateCopyWithImpl<$Res, TonWalletDetailsState>;
}

/// @nodoc
class _$TonWalletDetailsStateCopyWithImpl<$Res,
        $Val extends TonWalletDetailsState>
    implements $TonWalletDetailsStateCopyWith<$Res> {
  _$TonWalletDetailsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$TonWalletDetailsStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'TonWalletDetailsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() empty,
    required TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)
        subscribeError,
    required TResult Function(String symbol, KeyAccount account,
            Money tokenBalance, Money fiatBalance)
        data,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? empty,
    TResult? Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult? Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? empty,
    TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Empty value) empty,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_Data value) data,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Empty value)? empty,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_Data value)? data,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Empty value)? empty,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_Data value)? data,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements TonWalletDetailsState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$TonWalletDetailsStateCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$EmptyImpl implements _Empty {
  const _$EmptyImpl();

  @override
  String toString() {
    return 'TonWalletDetailsState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() empty,
    required TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)
        subscribeError,
    required TResult Function(String symbol, KeyAccount account,
            Money tokenBalance, Money fiatBalance)
        data,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? empty,
    TResult? Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult? Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? empty,
    TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Empty value) empty,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_Data value) data,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Empty value)? empty,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_Data value)? data,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Empty value)? empty,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_Data value)? data,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _Empty implements TonWalletDetailsState {
  const factory _Empty() = _$EmptyImpl;
}

/// @nodoc
abstract class _$$SubscribeErrorImplCopyWith<$Res> {
  factory _$$SubscribeErrorImplCopyWith(_$SubscribeErrorImpl value,
          $Res Function(_$SubscribeErrorImpl) then) =
      __$$SubscribeErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String symbol, KeyAccount account, Object error, bool isLoading});
}

/// @nodoc
class __$$SubscribeErrorImplCopyWithImpl<$Res>
    extends _$TonWalletDetailsStateCopyWithImpl<$Res, _$SubscribeErrorImpl>
    implements _$$SubscribeErrorImplCopyWith<$Res> {
  __$$SubscribeErrorImplCopyWithImpl(
      _$SubscribeErrorImpl _value, $Res Function(_$SubscribeErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = null,
    Object? account = null,
    Object? error = null,
    Object? isLoading = null,
  }) {
    return _then(_$SubscribeErrorImpl(
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as KeyAccount,
      error: null == error ? _value.error : error,
      isLoading: null == isLoading
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$SubscribeErrorImpl implements _SubscribeError {
  const _$SubscribeErrorImpl(
      {required this.symbol,
      required this.account,
      required this.error,
      required this.isLoading});

  @override
  final String symbol;
  @override
  final KeyAccount account;
  @override
  final Object error;
  @override
  final bool isLoading;

  @override
  String toString() {
    return 'TonWalletDetailsState.subscribeError(symbol: $symbol, account: $account, error: $error, isLoading: $isLoading)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscribeErrorImpl &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.account, account) || other.account == account) &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading));
  }

  @override
  int get hashCode => Object.hash(runtimeType, symbol, account,
      const DeepCollectionEquality().hash(error), isLoading);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscribeErrorImplCopyWith<_$SubscribeErrorImpl> get copyWith =>
      __$$SubscribeErrorImplCopyWithImpl<_$SubscribeErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() empty,
    required TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)
        subscribeError,
    required TResult Function(String symbol, KeyAccount account,
            Money tokenBalance, Money fiatBalance)
        data,
  }) {
    return subscribeError(symbol, account, error, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? empty,
    TResult? Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult? Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
  }) {
    return subscribeError?.call(symbol, account, error, isLoading);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? empty,
    TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
    required TResult orElse(),
  }) {
    if (subscribeError != null) {
      return subscribeError(symbol, account, error, isLoading);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Empty value) empty,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_Data value) data,
  }) {
    return subscribeError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Empty value)? empty,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_Data value)? data,
  }) {
    return subscribeError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Empty value)? empty,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_Data value)? data,
    required TResult orElse(),
  }) {
    if (subscribeError != null) {
      return subscribeError(this);
    }
    return orElse();
  }
}

abstract class _SubscribeError implements TonWalletDetailsState {
  const factory _SubscribeError(
      {required final String symbol,
      required final KeyAccount account,
      required final Object error,
      required final bool isLoading}) = _$SubscribeErrorImpl;

  String get symbol;
  KeyAccount get account;
  Object get error;
  bool get isLoading;

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubscribeErrorImplCopyWith<_$SubscribeErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataImplCopyWith<$Res> {
  factory _$$DataImplCopyWith(
          _$DataImpl value, $Res Function(_$DataImpl) then) =
      __$$DataImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String symbol,
      KeyAccount account,
      Money tokenBalance,
      Money fiatBalance});
}

/// @nodoc
class __$$DataImplCopyWithImpl<$Res>
    extends _$TonWalletDetailsStateCopyWithImpl<$Res, _$DataImpl>
    implements _$$DataImplCopyWith<$Res> {
  __$$DataImplCopyWithImpl(_$DataImpl _value, $Res Function(_$DataImpl) _then)
      : super(_value, _then);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = null,
    Object? account = null,
    Object? tokenBalance = null,
    Object? fiatBalance = null,
  }) {
    return _then(_$DataImpl(
      symbol: null == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as KeyAccount,
      tokenBalance: null == tokenBalance
          ? _value.tokenBalance
          : tokenBalance // ignore: cast_nullable_to_non_nullable
              as Money,
      fiatBalance: null == fiatBalance
          ? _value.fiatBalance
          : fiatBalance // ignore: cast_nullable_to_non_nullable
              as Money,
    ));
  }
}

/// @nodoc

class _$DataImpl implements _Data {
  const _$DataImpl(
      {required this.symbol,
      required this.account,
      required this.tokenBalance,
      required this.fiatBalance});

  @override
  final String symbol;
  @override
  final KeyAccount account;
  @override
  final Money tokenBalance;
  @override
  final Money fiatBalance;

  @override
  String toString() {
    return 'TonWalletDetailsState.data(symbol: $symbol, account: $account, tokenBalance: $tokenBalance, fiatBalance: $fiatBalance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataImpl &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.tokenBalance, tokenBalance) ||
                other.tokenBalance == tokenBalance) &&
            (identical(other.fiatBalance, fiatBalance) ||
                other.fiatBalance == fiatBalance));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, symbol, account, tokenBalance, fiatBalance);

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DataImplCopyWith<_$DataImpl> get copyWith =>
      __$$DataImplCopyWithImpl<_$DataImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() empty,
    required TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)
        subscribeError,
    required TResult Function(String symbol, KeyAccount account,
            Money tokenBalance, Money fiatBalance)
        data,
  }) {
    return data(symbol, account, tokenBalance, fiatBalance);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? empty,
    TResult? Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult? Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
  }) {
    return data?.call(symbol, account, tokenBalance, fiatBalance);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? empty,
    TResult Function(
            String symbol, KeyAccount account, Object error, bool isLoading)?
        subscribeError,
    TResult Function(String symbol, KeyAccount account, Money tokenBalance,
            Money fiatBalance)?
        data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(symbol, account, tokenBalance, fiatBalance);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Empty value) empty,
    required TResult Function(_SubscribeError value) subscribeError,
    required TResult Function(_Data value) data,
  }) {
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Empty value)? empty,
    TResult? Function(_SubscribeError value)? subscribeError,
    TResult? Function(_Data value)? data,
  }) {
    return data?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Empty value)? empty,
    TResult Function(_SubscribeError value)? subscribeError,
    TResult Function(_Data value)? data,
    required TResult orElse(),
  }) {
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class _Data implements TonWalletDetailsState {
  const factory _Data(
      {required final String symbol,
      required final KeyAccount account,
      required final Money tokenBalance,
      required final Money fiatBalance}) = _$DataImpl;

  String get symbol;
  KeyAccount get account;
  Money get tokenBalance;
  Money get fiatBalance;

  /// Create a copy of TonWalletDetailsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DataImplCopyWith<_$DataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
